import React, { createContext, ReactElement, ReactNode, RefObject, useContext, useEffect, useRef, useState } from "react";
import {Device, types as MediasoupTypes} from "mediasoup-client"
import { InitialiseConnection, InitialiseConsumerTransportListener, InitialiseProducerTransportListener, onConsumerTransportCreated, onProducerTransportCreated, sendRequest } from "../websocket/websocket";

type GlobalContextType = {
    globalState: RefObject<GlobalStateType | null>
    socket: RefObject<WebSocket | null>
    device: RefObject<MediasoupTypes.Device>
    InitSocket: (userName: string) => void
    localVideoRef: RefObject<HTMLVideoElement>
    JoinMeeting: (userName: string, meetId: string) => void
    participants: ParticipantType | undefined
}

type GlobalStateType = {
    meetId: string
    createdAt?: string,
    currentUser: {
        userName: string
        userKey?: string
    },
    host?: {
        hostName: string,
        hostKey: string
    },
    participants?: ParticipantType
}

export type ParticipantType = {
    [key: string]: {
        userName: string,
        userKey: string,
        preference: {
            audio: boolean,
            video: boolean,
            screen: boolean
        },
        remoteStream?: MediaStream,
        producerId?: string
    }
}

export enum FormType {
    CREATE = 'create',
    JOIN = 'join'
}

export const GlobalContext = createContext<GlobalContextType | null>(null);

export function useGlobalState():GlobalContextType {
    const context = useContext(GlobalContext);
    if (!context) {
        throw new Error("useGlobalContext must be used within an GlobalProvider");
    }
    return context;
}

export const GlobalProvider = (props: {children: ReactNode}):ReactElement => {

    const globalState = useRef<GlobalStateType | null>(null);
    const socket = useRef<WebSocket | null>(null);
    const device = useRef<MediasoupTypes.Device>(new Device());
   
    const localVideoRef = useRef<any>(null);

    const consumerTransport = useRef<MediasoupTypes.Transport | null>(null);
    const producerTransport = useRef<MediasoupTypes.Transport | null>(null);

    const [participants, setParticipants] = useState<ParticipantType>();

    const startConsuming = () => {
        if(globalState.current?.participants){
            const participants = globalState.current?.participants;
            const currentUser = globalState.current.currentUser;
            Object.keys(participants).forEach( (key) => {
                if(participants[key].producerId && socket.current && consumerTransport.current && globalState.current && currentUser.userKey){
                    console.log("New Participant  : ", globalState.current, "consumer : ", consumerTransport.current);
                    InitialiseConsumerTransportListener(consumerTransport.current, device.current ,socket.current, globalState.current.meetId, currentUser.userKey);
                    sendRequest(socket.current, "startConsume", {
                        rtpCapabilities: device.current.rtpCapabilities, 
                        producerId: participants[key].producerId, 
                        producerUserKey: key, 
                        meetId: globalState.current.meetId, 
                        userKey: globalState.current.currentUser.userKey
                    });
                }
                
            });
        }
    }

    const InitSocket = async(userName: string) => {
        socket.current = await InitialiseConnection();
        globalState.current = {
            currentUser: {
                userName
            },
            meetId: ''
        };
        socket.current.onopen = () => {
            if(socket.current){
                console.log("WebSocket Connected!");
                sendRequest(socket.current, "createMeeting", {userName});
            }
        }
        socket.current.onmessage = async(event: MessageEvent) => {
            
            const message = JSON.parse(event.data);
            console.log("New Message : ", message);
            let type = message.type;
            let response = message.response;
            
            switch(type){
                case "meetingCreated": 
                       if(socket.current && response.meetInfo && globalState.current){
                            globalState.current.meetId = response.meetInfo.meetId;
                            globalState.current.host = response.meetInfo.host;
                            try{
                                await device.current.load({routerRtpCapabilities: response.meetInfo.rtpCapabilities}).then( () => {
                                 if(socket.current && globalState.current)
                                     sendRequest(socket.current, "createProducerTransport", {
                                        forceTcp: false, 
                                        rtpCapabilities: device.current,
                                        meetId: globalState.current.meetId, 
                                        userName: globalState.current.currentUser.userName
                                    })
                                });
                                
                            }catch(error){
                                 console.log("Device Load Error : ", error);
                            }
                       }
                break;

                case "newUser": 
                       
                       if( globalState.current && globalState.current?.currentUser.userKey &&response.user.userKey != globalState.current?.currentUser.userKey){
                            let user: ParticipantType = {
                                [response.user.userKey]: {
                                    userName: response.user.userName,
                                    userKey: response.user.userKey,
                                    preference: response.user.preference,
                                    producerId: response.user.producerId
                                }
                            }
                            globalState.current.participants = {...globalState.current?.participants, ...user};
                            console.log("New user : ", globalState.current.participants);
                            startConsuming()
                       }
                break;

                case "producerTransportCreated": 
                    if(device.current && socket.current && response.params && response.user && globalState.current){
                        globalState.current.currentUser = {
                            userName: response.user.userName,
                            userKey: response.user.userKey
                        }
                        const producer = await onProducerTransportCreated(response.params, device.current);
                        producerTransport.current = producer;
                        InitialiseProducerTransportListener(producer, socket.current, device.current, localVideoRef, globalState.current.meetId, response.user.userKey);
                    }
                break;


                case "consumerTransportCreated":
                    if(device.current && socket.current && globalState.current?.currentUser.userKey){
                        const consumer = await onConsumerTransportCreated(response.params, device.current); //consumerTransport
                        consumer.on( "connect", ({dtlsParameters}, callback) => {
                            if(socket.current){
                                sendRequest(socket.current, "connectConsumerTransport", {transportId: consumer.id, dtlsParameters, meetId: globalState.current?.meetId, userKey: globalState.current?.currentUser.userKey});
                                socket.current.addEventListener( "message",  (event: MessageEvent) => {
                                    let data = JSON.parse(event.data);
                                    if(data.type == "consumerConnected"){
                                        callback();
                                    }
                                });
                            }
                            
                        });
                        consumerTransport.current = consumer;
                    }
                break;


                case "consumed":
                    if(consumerTransport.current){
                        console.log("Consumed : ", response)
                        let data = {
                            consumerId: response.data.consumerId,
                            producerId: response.data.producerId,
                            kind: response.data.kind,
                            rtpParameters: response.data.rtpParameters
                        }
                        
                        await consumerTransport.current?.consume({
                            id: data.consumerId,
                            producerId: data.producerId,
                            kind: data.kind,
                            rtpParameters: data.rtpParameters
                        }).then( (consumer) => {
                            console.log("Consumer Track : ", consumer.track);
                            const stream = new MediaStream();
                            stream.addTrack(consumer.track);
                           if(response.producerUserKey && globalState.current?.participants ){
                                globalState.current.participants[response.producerUserKey] = { ...globalState.current.participants[response.producerUserKey], remoteStream: stream};
                                console.log("Updated : ", globalState.current.participants)
                                setParticipants(globalState.current.participants);
                           }
                        });
                    }
                break;
            }
        }
    }

  

    const JoinMeeting = async(userName: string, meetId: string) => {   

        socket.current = await InitialiseConnection();
        console.log("Join :" ,globalState.current)
        globalState.current = {
            currentUser: {
                userName
            },
            meetId
        };
        socket.current.onopen = () => {
            if(socket.current){
                console.log("WebSocket Connected!");
                sendRequest(socket.current, "joinMeeting", {meetId, userName});
            }
        }

        socket.current.onmessage = async(event: MessageEvent) => {
            const message = JSON.parse(event.data);
            console.log("New Message : ", message);
            let type = message.type;
            let response = message.response;

            switch(type){
                case "joinedMeeting" : 
                    if(socket.current && response.meetInfo && globalState.current){
                        globalState.current.meetId = response.meetInfo.meetId;
                        globalState.current.host = response.meetInfo.host;
                        try{
                            await device.current.load({routerRtpCapabilities: response.meetInfo.rtpCapabilities}).then( () => {
                            if(socket.current && globalState.current)
                                sendRequest(socket.current, "createProducerTransport", {
                                    forceTcp: false, 
                                    rtpCapabilities: device.current,
                                    meetId: globalState.current.meetId, 
                                    userName: globalState.current.currentUser.userName
                                })
                            });
                            
                        }catch(error){
                            console.log("Device Load Error : ", error);
                        }
                    }
                break;

                case "newUser": 
                       
                       if( globalState.current && globalState.current?.currentUser.userKey &&response.user.userKey != globalState.current?.currentUser.userKey){
                            let user: ParticipantType = {
                                [response.user.userKey]: {
                                    userName: response.user.userName,
                                    userKey: response.user.userKey,
                                    preference: response.user.preference,
                                    producerId: response.user.producerId
                                }
                            }
                            globalState.current.participants = {...globalState.current?.participants, ...user};
                            console.log("New user : ", globalState.current.participants);
                            startConsuming()
                       }
                break;


                case "producerTransportCreated": 
                if(device.current && socket.current && response.params && response.user && globalState.current){
                    globalState.current.currentUser = {
                        userName: response.user.userName,
                        userKey: response.user.userKey
                    }
                    const producer = await onProducerTransportCreated(response.params, device.current);
                    producerTransport.current = producer;
                    InitialiseProducerTransportListener(producer, socket.current, device.current, localVideoRef, globalState.current.meetId, response.user.userKey);
                }
            break;

                case "consumerTransportCreated":
                    if(device.current && socket.current && globalState.current?.currentUser.userKey){
                        const consumer = await onConsumerTransportCreated(response.params, device.current); //consumerTransport
                        consumerTransport.current = consumer;
                        startConsuming();
                        consumer.on( "connect", ({dtlsParameters}, callback) => {
                            if(socket.current){
                                sendRequest(socket.current, "connectConsumerTransport", {transportId: consumer.id, dtlsParameters, meetId: globalState.current?.meetId, userKey: globalState.current?.currentUser.userKey});
                                socket.current.addEventListener( "message",  (event: MessageEvent) => {
                                    let data = JSON.parse(event.data);
                                    if(data.type == "consumerConnected"){
                                        callback();
                                    }
                                });
                            }
                            
                        });
                        
                    }
                break;

                case "consumed":
                    if(consumerTransport.current){
                        console.log("Consumed : ", response)
                        let data = {
                            consumerId: response.data.consumerId,
                            producerId: response.data.producerId,
                            kind: response.data.kind,
                            rtpParameters: response.data.rtpParameters
                        }
                        
                        await consumerTransport.current?.consume({
                            id: data.consumerId,
                            producerId: data.producerId,
                            kind: data.kind,
                            rtpParameters: data.rtpParameters
                        }).then( (consumer) => {
                            console.log("Consumer Track : ", consumer.track);
                            const stream = new MediaStream();
                            stream.addTrack(consumer.track);
                           if(response.producerUserKey && globalState.current?.participants ){
                                globalState.current.participants[response.producerUserKey] = { ...globalState.current.participants[response.producerUserKey], remoteStream: stream};
                                console.log("Updated : ", globalState.current.participants);
                                setParticipants(globalState.current.participants);
                           }
                        });
                    }
                break;
                        
            }
        }
    }
   
    return(
    <GlobalContext.Provider value={{globalState, socket, device, InitSocket, localVideoRef, JoinMeeting, participants}}>
        {props.children}
    </GlobalContext.Provider>
   )
}