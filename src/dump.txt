import React, { createContext, ReactElement, ReactNode, RefObject, useContext, useEffect, useRef, useState } from "react";
import {Device, types as MediasoupTypes} from "mediasoup-client"
import { InitialiseConnection, InitialiseConsumerTransportListener, InitialiseProducerTransportListener, InitialiseProducerTransportListenerJoinSession, onConsumerTransportCreated, onProducerTransportCreated, sendRequest } from "../websocket/websocket";

type GlobalContextType = {
    globalState: RefObject<GlobalStateType | null>
    socket: RefObject<WebSocket | null>
    device: RefObject<MediasoupTypes.Device>
    InitSocket: (userName: string) => void
    localVideoRef: RefObject<HTMLVideoElement>
    JoinMeeting: (userName: string, meetId: string) => void
    participants: ParticipantType | undefined
}

type GlobalStateType = {
    meetId: string
    createdAt?: string,
    currentUser: {
        userName: string
        userKey?: string
    },
    host?: {
        hostName: string,
        hostKey: string
    },
    participants?: ParticipantType
}

export type ParticipantType = {
    [key: string]: {
        userName: string,
        userKey: string,
        preference: {
            audio: boolean,
            video: boolean,
            screen: boolean
        },
        remoteStream?: MediaStream,
        producerId?: string
    }
}

export enum FormType {
    CREATE = 'create',
    JOIN = 'join'
}

export const GlobalContext = createContext<GlobalContextType | null>(null);

export function useGlobalState():GlobalContextType {
    const context = useContext(GlobalContext);
    if (!context) {
        throw new Error("useGlobalContext must be used within an GlobalProvider");
    }
    return context;
}

export const GlobalProvider = (props: {children: ReactNode}):ReactElement => {

    const globalState = useRef<GlobalStateType | null>(null);
    const socket = useRef<WebSocket | null>(null);
    const device = useRef<MediasoupTypes.Device>(new Device());
   
    const localVideoRef = useRef<any>(null);

    const consumerTransport = useRef<MediasoupTypes.Transport | null>(null);
    const producerTransport = useRef<MediasoupTypes.Transport | null>(null);

    const [participants, setParticipants] = useState<ParticipantType>();

    const startConsuming = (producerId: string, userKey: string) => {
        if(consumerTransport.current && socket.current && globalState.current?.currentUser.userKey){
            // InitialiseConsumerTransportListener(consumerTransport.current, device.current ,socket.current, globalState.current.meetId, globalState.current.currentUser.userKey);
            sendRequest(socket.current, "startConsume", {
                rtpCapabilities: device.current.rtpCapabilities, 
                producerId: producerId, 
                producerUserKey: userKey, 
                meetId: globalState.current.meetId, 
                userKey: globalState.current.currentUser.userKey
            });
        }
        
    }

    const InitSocket = async(userName: string) => {
        socket.current = await InitialiseConnection();
        globalState.current = {
            currentUser: {
                userName
            },
            meetId: ''
        };
        socket.current.onopen = () => {
            if(socket.current){
                console.log("WebSocket Connected!", socket.current);
                sendRequest(socket.current, "createMeeting", {userName});
            }
        }
        window.addEventListener("beforeunload", function (event) {
            if(socket.current)
                sendRequest(socket.current, "leaveMeeting", {meetId: globalState.current?.meetId, user: globalState.current?.currentUser});
            
        });
        socket.current.onmessage = async(event: MessageEvent) => {
            
            const message = JSON.parse(event.data);
            console.log("New Message : ", message);
            let type = message.type;
            let response = message.response;
            
            switch(type){
                case "meetingCreated": 
                       if(socket.current && response.meetInfo && globalState.current){
                            globalState.current.meetId = response.meetInfo.meetId;
                            globalState.current.host = response.meetInfo.host;
                            globalState.current.currentUser = {
                                userName: response.meetInfo.host.hostName,
                                userKey: response.meetInfo.host.hostKey
                            }
                            try{
                                await device.current.load({routerRtpCapabilities: response.meetInfo.rtpCapabilities}).then( () => {
                                 if(socket.current && globalState.current)
                                     sendRequest(socket.current, "createProducerTransport", {
                                        forceTcp: false, 
                                        rtpCapabilities: device.current,
                                        meetId: globalState.current.meetId, 
                                        userKey: globalState.current.currentUser.userKey
                                    })
                                });
                                
                            }catch(error){
                                 console.log("Device Load Error : ", error);
                            }
                       }
                break;

                case "newUser": 
                       if( globalState.current && globalState.current?.currentUser.userKey &&response.user.userKey != globalState.current?.currentUser.userKey){
                            let user: ParticipantType = {
                                [response.user.userKey]: {
                                    userName: response.user.userName,
                                    userKey: response.user.userKey,
                                    preference: response.user.preference,
                                    producerId: response.user.producerId
                                }
                            }
                            globalState.current.participants = {...globalState.current?.participants, ...user};
                            if(response.user.userKey != globalState.current.currentUser.userKey)
                                startConsuming(response.user.producerId, response.user.userKey);
                       }
                break;

                case "producerTransportCreated": 
                    if(device.current && socket.current && response.params && globalState.current && globalState.current.currentUser){
                        const producer = await onProducerTransportCreated(response.params, device.current);
                        producerTransport.current = producer;
                        InitialiseProducerTransportListener(producer, socket.current, device.current, localVideoRef, globalState.current.meetId, globalState.current.currentUser);
                    }
                break;


                case "consumerTransportCreated":
                    if(device.current && socket.current && globalState.current?.currentUser.userKey){
                        const consumer = await onConsumerTransportCreated(response.params, device.current); //consumerTransport
                        consumer.on( "connect", ({dtlsParameters}, callback) => {
                            if(socket.current){
                                sendRequest(socket.current, "connectConsumerTransport", {transportId: consumer.id, dtlsParameters, meetId: globalState.current?.meetId, userKey: globalState.current?.currentUser.userKey});
                                socket.current.addEventListener( "message",  (event: MessageEvent) => {
                                    let data = JSON.parse(event.data);
                                    if(data.type == "consumerConnected"){
                                        callback();
                                    }
                                });
                            }
                            
                        });
                        consumerTransport.current = consumer;
                    }
                break;


                case "consumed":
                    if(consumerTransport.current){
                        let data = {
                            consumerId: response.data.consumerId,
                            producerId: response.data.producerId,
                            kind: response.data.kind,
                            rtpParameters: response.data.rtpParameters
                        }
                        try{
                            await consumerTransport.current.consume({
                                id: data.consumerId,
                                producerId: data.producerId,
                                kind: data.kind,
                                rtpParameters: data.rtpParameters
                            }).then( (consumer) => {
                                const stream = new MediaStream();
                                stream.addTrack(consumer.track);
                                
                               if(response.producerUserKey && globalState.current?.participants ){
                                    globalState.current.participants[response.producerUserKey] = { ...globalState.current.participants[response.producerUserKey], remoteStream: stream};
                                    console.log("Consume User : ",  globalState.current.participants[response.producerUserKey])
                                    setParticipants(globalState.current.participants);
                               }
                            });
                        }catch(error){
                            console.log("Consume Error : ", error);
                        }
                        
                    }
                break;
            }
        }
    }

  

    const JoinMeeting = async(userName: string, meetId: string) => {   

        socket.current = await InitialiseConnection();
        console.log("Join :" ,globalState.current)
        globalState.current = {
            currentUser: {
                userName
            },
            meetId
        };
        socket.current.onopen = () => {
            if(socket.current){
                console.log("WebSocket Connected!");
                sendRequest(socket.current, "joinMeeting", {meetId, userName});
            }
        }
        window.addEventListener("beforeunload", function (event) {
            if(socket.current)
                sendRequest(socket.current, "leaveMeeting", {meetId: globalState.current?.meetId, user: globalState.current?.currentUser});
            
        });
        socket.current.onmessage = async(event: MessageEvent) => {
            const message = JSON.parse(event.data);
            console.log("New Message : ", message);
            let type = message.type;
            let response = message.response;

            switch(type){
                case "joinedMeeting" : 
                    if(socket.current && response.meetInfo && globalState.current){
                        globalState.current.meetId = response.meetInfo.meetId;
                        globalState.current.host = response.meetInfo.host;
                        globalState.current.currentUser.userKey = response.meetInfo.userKey
                        try{
                            await device.current.load({routerRtpCapabilities: response.meetInfo.rtpCapabilities}).then( () => {
                            if(socket.current && globalState.current)
                                sendRequest(socket.current, "createProducerTransport", {
                                    forceTcp: false, 
                                    rtpCapabilities: device.current,
                                    meetId: globalState.current.meetId, 
                                    userKey: globalState.current.currentUser.userKey
                                })
                            });
                            
                        }catch(error){
                            console.log("Device Load Error : ", error);
                        }
                    }
                break;

                case "newUser": 
                       
                       if( globalState.current && globalState.current?.currentUser.userKey &&response.user.userKey != globalState.current?.currentUser.userKey){
                            let user: ParticipantType = {
                                [response.user.userKey]: {
                                    userName: response.user.userName,
                                    userKey: response.user.userKey,
                                    preference: response.user.preference,
                                    producerId: response.user.producerId
                                }
                            }
                            globalState.current.participants = {...globalState.current?.participants, ...user};
                            if(response.user.userKey != globalState.current.currentUser.userKey)
                                startConsuming(response.user.producerId, response.user.userKey);
                       }
                break;


                case "producerTransportCreated": 
                    if(device.current && socket.current && response.params && globalState.current && globalState.current.currentUser){
                        const producer = await onProducerTransportCreated(response.params, device.current);
                        producerTransport.current = producer;
                        sendRequest(socket.current, "createConsumerTransport", {meetId: globalState.current.meetId, userKey: globalState.current.currentUser.userKey});
                        InitialiseProducerTransportListenerJoinSession(producer, socket.current, device.current, localVideoRef, globalState.current.meetId, globalState.current.currentUser);
                    }
                break;

                case "consumerTransportCreated":
                    if(device.current && socket.current && globalState.current?.currentUser.userKey){
                        const consumer = await onConsumerTransportCreated(response.params, device.current); //consumerTransport
                        consumerTransport.current = consumer;
                        consumer.on( "connect", ({dtlsParameters}, callback) => {
                            if(socket.current){
                                sendRequest(socket.current, "connectConsumerTransport", {transportId: consumer.id, dtlsParameters, meetId: globalState.current?.meetId, userKey: globalState.current?.currentUser.userKey});
                                socket.current.addEventListener( "message",  (event: MessageEvent) => {
                                    let data = JSON.parse(event.data);
                                    if(data.type == "consumerConnected"){
                                        callback();
                                    }
                                });
                            }
                            
                        });
                        
                    }
                break;

                case "consumed":
                    if(consumerTransport.current){
                        let data = {
                            consumerId: response.data.consumerId,
                            producerId: response.data.producerId,
                            kind: response.data.kind,
                            rtpParameters: response.data.rtpParameters
                        }
                        try{
                            const consumer = await consumerTransport.current.consume({
                                id: data.consumerId,
                                producerId: data.producerId,
                                kind: data.kind,
                                rtpParameters: data.rtpParameters
                            })
                            const stream = new MediaStream();
                            stream.addTrack(consumer.track);
                            
                           if(response.producerUserKey && globalState.current?.participants && globalState.current.participants[response.producerUserKey]){
                                const participants = { ...globalState.current.participants };
                                participants[response.producerUserKey] = {
                                    ...participants[response.producerUserKey],
                                    remoteStream: stream
                                  };
                               
                                globalState.current.participants = participants;
                                console.log("Consume User : ",  globalState.current.participants[response.producerUserKey]);
                                setParticipants({ ...participants });
                                console.log("updated Participants : ", participants);
                           }
                        }catch(error){
                            console.log("Consume Error : ", error);
                        }
                        
                    }
                break;
                        
            }
        }
    }
   
    return(
    <GlobalContext.Provider value={{globalState, socket, device, InitSocket, localVideoRef, JoinMeeting, participants}}>
        {props.children}
    </GlobalContext.Provider>
   )
}